{"ast":null,"code":"export async function* MergeSort(array, combine, highlight, markSort) {\n  let offSet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let finalMerge = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  if (array.length === 1) {\n    if (finalMerge) markSort(0);\n    return array;\n  }\n\n  const middle = Math.floor(array.length / 2);\n  const left = array.slice(0, middle);\n  const right = array.slice(middle);\n  const arr = yield* await merge(yield* await MergeSort(left, combine, highlight, markSort, offSet, false), yield* await MergeSort(right, combine, highlight, markSort, offSet + middle, false), offSet, offSet + middle, finalMerge, markSort);\n  return arr;\n\n  async function* merge(left, right, off1, off2) {\n    let finalMerge = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let markSort = arguments.length > 5 ? arguments[5] : undefined;\n    let result = [];\n    let leftIndex = 0;\n    let rightIndex = 0;\n\n    while (leftIndex < left.length && rightIndex < right.length) {\n      if (left[leftIndex] <= right[rightIndex]) {\n        yield await highlight([off1 + leftIndex + rightIndex, off2 + rightIndex]);\n        yield await combine(off1 + leftIndex + rightIndex, off1 + result.length);\n        if (finalMerge) yield await markSort(off1 + result.length);\n        result.push(left[leftIndex]);\n        leftIndex++;\n      } else {\n        yield await highlight([off1 + leftIndex + rightIndex, off2 + rightIndex]);\n        yield await combine(off2 + rightIndex, off1 + result.length);\n        if (finalMerge) yield await markSort(off1 + result.length);\n        result.push(right[rightIndex]);\n        rightIndex++;\n      }\n    }\n\n    while (leftIndex < left.length) {\n      yield await highlight([off1 + leftIndex + rightIndex]);\n      if (finalMerge) yield await markSort(off1 + leftIndex + rightIndex);\n      result.push(left[leftIndex]);\n      leftIndex++;\n    }\n\n    while (rightIndex < right.length) {\n      yield await highlight([off1 + leftIndex + rightIndex]);\n      if (finalMerge) yield await markSort(off1 + leftIndex + rightIndex);\n      result.push(right[rightIndex]);\n      rightIndex++;\n    }\n\n    return result;\n  }\n}\n_c = MergeSort;\n\nvar _c;\n\n$RefreshReg$(_c, \"MergeSort\");","map":{"version":3,"names":["MergeSort","array","combine","highlight","markSort","offSet","finalMerge","length","middle","Math","floor","left","slice","right","arr","merge","off1","off2","result","leftIndex","rightIndex","push"],"sources":["C:/Users/ACER/Desktop/sorting-visualizer-main/src/sortFunctions/MergeSort.js"],"sourcesContent":["export async function* MergeSort(\n  array,\n  combine,\n  highlight,\n  markSort,\n  offSet = 0,\n  finalMerge = true\n) {\n  if (array.length === 1) {\n    if(finalMerge)\n      markSort(0);\n    return array;\n  }\n\n  const middle = Math.floor(array.length / 2);\n  const left = array.slice(0, middle);\n  const right = array.slice(middle);\n\n  const arr = yield* await merge(\n    yield* await MergeSort(left, combine, highlight, markSort, offSet, false),\n    yield* await MergeSort(right, combine, highlight, markSort, offSet + middle, false),\n    offSet,\n    offSet + middle,\n    finalMerge,\n    markSort\n  );\n  return arr;\n\n  async function* merge(left, right, off1, off2, finalMerge = false, markSort) {\n    let result = [];\n    let leftIndex = 0;\n    let rightIndex = 0;\n\n    while (leftIndex < left.length && rightIndex < right.length) {\n      if (left[leftIndex] <= right[rightIndex]) {\n        yield await highlight([off1 + leftIndex + rightIndex, off2 + rightIndex]);\n        yield await combine(\n          off1 + leftIndex + rightIndex,\n          off1 + result.length,\n        );\n        if(finalMerge)\n          yield await markSort(off1 + result.length);\n        result.push(left[leftIndex]);\n        leftIndex++;\n      } else {\n        yield await highlight([off1 + leftIndex + rightIndex, off2 + rightIndex]);\n        yield await combine(off2 + rightIndex, off1 + result.length);\n        if(finalMerge)\n          yield await markSort(off1 + result.length);\n        result.push(right[rightIndex]);\n        rightIndex++;\n      }\n    }\n\n    while (leftIndex < left.length) {\n      yield await highlight([off1 + leftIndex + rightIndex]);\n      if(finalMerge)\n        yield await markSort(off1 + leftIndex + rightIndex);\n      result.push(left[leftIndex]);\n      leftIndex++;\n    }\n\n    while (rightIndex < right.length) {\n      yield await highlight([off1 + leftIndex + rightIndex]);\n      if(finalMerge)\n        yield await markSort(off1 + leftIndex + rightIndex);\n      result.push(right[rightIndex]);\n      rightIndex++;\n    }\n\n    return result;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}